{"version":3,"sources":["components/GameShell/GameShell.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Keys","GameShell","props","canvasRef","React","createRef","state","tick","ctx","this","current","getContext","fillStyle","game","Game","canvasSize","start","window","addEventListener","event","handleKey","keyCode","ref","width","height","style","border","Component","positionsEqual","left","right","posX","posY","Worm","headPosition","size","direction","DOWN","_headPosition","body","push","value","length","shift","canvasSizeinPx","blockSize","wormsNumber","snacksNumber","intervalId","fps","snacks","worms","step","index","initSnacks","setSnackPosition","newSnackPosition","Math","floor","random","canvasSizeInBlocks","some","x","y","setInterval","run","clearInterval","worm","move","key","LEFT","changeDirection","draw","newPosition","moveTowards","possibleMove","checkMove","checkSnack","clearRect","wI","element","fillRect","sI","snack","Object","values","includes","SPACE","UP","RIGHT","console","log","position","App","className","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3e3813bf.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\ninterface GameShellProps {\r\n  canvasSize: CanvasSize;\r\n}\r\n\r\ninterface CanvasSize {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport default class GameShell extends React.Component<\r\n  GameShellProps,\r\n  { tick: number }\r\n> {\r\n  private canvasRef: React.RefObject<HTMLCanvasElement>;\r\n\r\n  constructor(props: GameShellProps) {\r\n    super(props);\r\n    this.canvasRef = React.createRef();\r\n\r\n    this.state = {\r\n      tick: 0\r\n    };\r\n  }\r\n\r\n  componentDidMount(): void {\r\n    const canvas = this.canvasRef.current as HTMLCanvasElement;\r\n    const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n    ctx.fillStyle = \"green\";\r\n    const game = new Game(ctx, this.props.canvasSize, 5, 100, 100);\r\n    game.start(true);\r\n    window.addEventListener(\"keydown\", (event: KeyboardEvent) =>\r\n      game.handleKey(event.keyCode)\r\n    );\r\n  }\r\n\r\n  public render(): JSX.Element {\r\n    return (\r\n      <canvas\r\n        ref={this.canvasRef}\r\n        width={this.props.canvasSize.width}\r\n        height={this.props.canvasSize.height}\r\n        style={{ border: \"1px solid\" }}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\ninterface Position {\r\n  posX: number;\r\n  posY: number;\r\n}\r\n\r\nconst positionsEqual = (left: Position, right: Position): boolean => {\r\n  return left.posX === right.posX && left.posY === right.posY;\r\n};\r\n\r\nexport enum Keys {\r\n  LEFT = 37,\r\n  UP = 38,\r\n  RIGHT = 39,\r\n  DOWN = 40,\r\n  SPACE = 32\r\n}\r\n\r\nclass Worm {\r\n  private _headPosition: Position = {\r\n    posX: 0,\r\n    posY: 0\r\n  };\r\n\r\n  public get headPosition(): Position {\r\n    return this._headPosition;\r\n  }\r\n\r\n  public set headPosition(value: Position) {\r\n    if (this.body.length >= this.size) {\r\n      this.body.shift();\r\n    }\r\n    this.body.push(value);\r\n    this._headPosition = value;\r\n  }\r\n\r\n  public body: Position[] = [];\r\n\r\n  constructor(\r\n    headPosition: Position = { posX: 0, posY: 0 },\r\n    public size: number = 3,\r\n    public direction: Keys = Keys.DOWN\r\n  ) {\r\n    this.headPosition = headPosition;\r\n    this.body.push(this.headPosition);\r\n  }\r\n}\r\n\r\nclass Game {\r\n  private intervalId?: NodeJS.Timeout;\r\n  private tick = 0;\r\n  private fps = 50;\r\n  private snacks: Position[] = [];\r\n\r\n  private worms: Worm[] = [];\r\n\r\n  private step = 1;\r\n\r\n  private get canvasSizeInBlocks(): CanvasSize {\r\n    return {\r\n      width: this.canvasSizeinPx.width / this.blockSize,\r\n      height: this.canvasSizeinPx.height / this.blockSize\r\n    };\r\n  }\r\n\r\n  constructor(\r\n    private ctx: CanvasRenderingContext2D,\r\n    private canvasSizeinPx: CanvasSize,\r\n    private blockSize = 100,\r\n    wormsNumber = 1,\r\n    snacksNumber = 1\r\n  ) {\r\n    for (let index = 0; index < wormsNumber; index++) {\r\n      this.worms.push(new Worm());\r\n    }\r\n    this.initSnacks(snacksNumber);\r\n  }\r\n\r\n  private async initSnacks(snacksNumber: number): Promise<void> {\r\n    for (let index = 0; index < snacksNumber; index++) {\r\n      this.snacks.push(await this.setSnackPosition());\r\n    }\r\n  }\r\n\r\n  private async setSnackPosition(): Promise<Position> {\r\n    let newSnackPosition = {\r\n      posX: Math.floor(Math.random() * this.canvasSizeInBlocks.width),\r\n      posY: Math.floor(Math.random() * this.canvasSizeInBlocks.height)\r\n    };\r\n    while (\r\n      this.worms.some(x =>\r\n        x.body.some(y => positionsEqual(y, newSnackPosition))\r\n      )\r\n    ) {\r\n      newSnackPosition = {\r\n        posX: Math.floor(Math.random() * this.canvasSizeInBlocks.width),\r\n        posY: Math.floor(Math.random() * this.canvasSizeInBlocks.height)\r\n      };\r\n    }\r\n    return newSnackPosition;\r\n  }\r\n\r\n  public start(random: boolean = false): void {\r\n    this.intervalId = setInterval(() => {\r\n      this.run(random);\r\n    }, 1000 / this.fps);\r\n  }\r\n\r\n  public stop(): void {\r\n    if (this.intervalId) {\r\n      clearInterval(this.intervalId);\r\n    }\r\n  }\r\n\r\n  private run(random: boolean): void {\r\n    this.tick++;\r\n    for (let index = 0; index < this.worms.length; index++) {\r\n      const worm = this.worms[index];\r\n      this.move(worm);\r\n      if (random) {\r\n        const key = Keys.LEFT + Math.floor(Math.random() * 4);\r\n        this.changeDirection(key, worm);\r\n      }\r\n    }\r\n    this.draw();\r\n  }\r\n\r\n  private async checkSnack(worm: Worm, index: number): Promise<void> {\r\n    const wormApproachedSnack = positionsEqual(this.snacks[index], worm.headPosition);\r\n    if (wormApproachedSnack) {\r\n      worm.size++;\r\n      this.snacks[index] = await this.setSnackPosition();\r\n    }\r\n  }\r\n\r\n  private move(worm: Worm): boolean {\r\n    const newPosition = this.moveTowards(worm.direction, worm);\r\n    const possibleMove = this.checkMove(newPosition);\r\n    if (possibleMove) {\r\n      for (let index = 0; index < this.snacks.length; index++) {\r\n        this.checkSnack(worm, index);\r\n      }\r\n      worm.headPosition = newPosition;\r\n      return possibleMove;\r\n    }\r\n    return possibleMove;\r\n  }\r\n\r\n  public draw(): void {\r\n    this.ctx.clearRect(\r\n      0,\r\n      0,\r\n      this.canvasSizeinPx.width,\r\n      this.canvasSizeinPx.height\r\n    );\r\n    for (let wI = 0; wI < this.worms.length; wI++) {\r\n      const worm = this.worms[wI];\r\n      for (let index = 0; index < worm.body.length; index++) {\r\n        const element = worm.body[index];\r\n        this.ctx.fillStyle = \"black\";\r\n        this.ctx.fillRect(\r\n          element.posX * this.blockSize,\r\n          element.posY * this.blockSize,\r\n          this.blockSize,\r\n          this.blockSize\r\n        );\r\n      }      \r\n    }\r\n    for (let sI = 0; sI < this.snacks.length; sI++) {\r\n      const snack = this.snacks[sI];\r\n      this.ctx.fillStyle = \"green\";\r\n      this.ctx.fillRect(\r\n        snack.posX * this.blockSize,\r\n        snack.posY * this.blockSize,\r\n        this.blockSize,\r\n        this.blockSize\r\n      );\r\n    }\r\n  }\r\n\r\n  public handleKey(key: Keys): void {\r\n    if (!Object.values(Keys).includes(key)) {\r\n      return;\r\n    }\r\n    this.changeDirection(key, this.worms[0]);\r\n    if (key === Keys.SPACE) {\r\n      this.worms[0].size++;\r\n    }\r\n  }\r\n\r\n  private changeDirection(key: Keys, worm: Worm): void {\r\n    if (worm.direction === Keys.DOWN && key === Keys.UP) {\r\n      return;\r\n    }\r\n    if (worm.direction === Keys.UP && key === Keys.DOWN) {\r\n      return;\r\n    }\r\n    if (worm.direction === Keys.LEFT && key === Keys.RIGHT) {\r\n      return;\r\n    }\r\n    if (worm.direction === Keys.RIGHT && key === Keys.LEFT) {\r\n      return;\r\n    }\r\n    worm.direction = key;\r\n  }\r\n\r\n  private moveTowards(key: Keys, worm: Worm): Position {\r\n    switch (key) {\r\n      case Keys.UP:\r\n        return {\r\n          posY: worm.headPosition.posY - this.step,\r\n          posX: worm.headPosition.posX\r\n        };\r\n      case Keys.DOWN:\r\n        return {\r\n          posY: worm.headPosition.posY + this.step,\r\n          posX: worm.headPosition.posX\r\n        };\r\n      case Keys.LEFT:\r\n        return {\r\n          posY: worm.headPosition.posY,\r\n          posX: worm.headPosition.posX - this.step\r\n        };\r\n      case Keys.RIGHT:\r\n        return {\r\n          posY: worm.headPosition.posY,\r\n          posX: worm.headPosition.posX + this.step\r\n        };\r\n      default:\r\n        console.log(\"no action assigned\");\r\n        return worm.headPosition;\r\n    }\r\n  }\r\n\r\n  private checkMove(position: Position): boolean {\r\n    if (\r\n      this.canvasSizeInBlocks.height < position.posY + this.step ||\r\n      position.posY < 0 ||\r\n      this.canvasSizeInBlocks.width < position.posX + this.step ||\r\n      position.posX < 0\r\n    ) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","import React from 'react';\nimport './App.css';\nimport GameShell from './components/GameShell/GameShell';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n        <GameShell canvasSize={{ width: 500, height: 800 }}></GameShell>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}