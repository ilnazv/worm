{"version":3,"sources":["components/GameShell/Models.ts","components/GameShell/Game.tsx","components/GameShell/GameShell.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Keys","getRandomPosition","canvasSizeInBlocks","posX","Math","floor","random","width","posY","height","positionsEqual","left","right","Worm","_headPosition","_size","direction","DOWN","body","dead","this","push","headPosition","value","size","length","shift","CanvasSize","canvas","blockSize","Game","ctx","canvasSizeinPx","fps","wormsNumber","snacksNumber","intervalId","tick","snacks","worms","step","survivorMode","_anotherWormCache","index","initSnacks","setSnackPosition","newSnackPosition","some","x","y","setInterval","run","clearInterval","filter","forEach","worm","possibleMove","move","tryCounter","key","LEFT","changeDirection","draw","stop","increaseSize","anotherWorm","find","newPosition","getNewPosition","checkNextMove","checkSnack","checkAnotherWorm","clearRect","element","fillStyle","fillRect","sI","snack","Object","values","includes","UP","RIGHT","console","log","GameShell","props","canvasRef","React","createRef","state","current","getContext","game","canvasSize","start","window","addEventListener","event","handleKey","keyCode","ref","style","border","Component","App","canvasWidth","innerWidth","canvasHeight","innerHeight","className","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.4e4725ab.chunk.js","sourcesContent":["export interface Position {\r\n  posX: number;\r\n  posY: number;\r\n}\r\n\r\nexport const getRandomPosition = (canvasSizeInBlocks: CanvasSize): Position => {\r\n  return {\r\n    posX: Math.floor(Math.random() * canvasSizeInBlocks.width),\r\n    posY: Math.floor(Math.random() * canvasSizeInBlocks.height)\r\n  };\r\n};\r\n\r\nexport const positionsEqual = (left: Position, right: Position): boolean => {\r\n  return left.posX === right.posX && left.posY === right.posY;\r\n};\r\n\r\nexport enum Keys {\r\n  LEFT = 37,\r\n  UP = 38,\r\n  RIGHT = 39,\r\n  DOWN = 40\r\n}\r\n\r\nexport class Worm {\r\n  public get headPosition(): Position {\r\n    return this._headPosition;\r\n  }\r\n\r\n  public set headPosition(value: Position) {\r\n    if (this.body.length >= this.size) {\r\n      this.body.shift();\r\n    }\r\n    this.body.push(value);\r\n    this._headPosition = value;\r\n  }\r\n\r\n  public body: Position[] = [];\r\n\r\n  public increaseSize(value: number = 1): void {\r\n    this._size = this.size + value;\r\n  }\r\n\r\n  public dead = false;\r\n\r\n  public get size(): number {\r\n    return this._size;\r\n  }\r\n\r\n  constructor(\r\n    private _headPosition: Position = { posX: 0, posY: 0 },\r\n    private _size: number = 3,\r\n    public direction: Keys = Keys.DOWN\r\n  ) {\r\n    this.body.push(this.headPosition);\r\n  }\r\n}\r\n\r\nexport class CanvasSize {\r\n  constructor(public width: number, public height: number) {}\r\n\r\n  public static canvasSizeInBlocks(canvas: CanvasSize, blockSize: number): CanvasSize {\r\n    return {\r\n      width: canvas.width / blockSize,\r\n      height: canvas.height / blockSize\r\n    };\r\n  }\r\n}\r\n","import { Worm, CanvasSize, positionsEqual, Keys, Position, getRandomPosition } from \"./Models\";\r\n\r\nexport class Game {\r\n  private intervalId?: NodeJS.Timeout;\r\n  private tick = 0;\r\n  private snacks: Position[] = [];\r\n\r\n  private worms: Worm[] = [];\r\n\r\n  private step = 1;\r\n\r\n  private survivorMode = false;\r\n\r\n  private _anotherWormCache?: Worm;\r\n\r\n  constructor(\r\n    private ctx: CanvasRenderingContext2D,\r\n    private canvasSizeinPx: CanvasSize,\r\n    private fps = 50,\r\n    private blockSize = 100,\r\n    wormsNumber = 1,\r\n    snacksNumber = 1\r\n  ) {\r\n    for (let index = 0; index < wormsNumber; index++) {\r\n      const canvasSizeInBlocks = CanvasSize.canvasSizeInBlocks(this.canvasSizeinPx, this.blockSize);\r\n      this.worms.push(new Worm(getRandomPosition(canvasSizeInBlocks)));\r\n    }\r\n    this.initSnacks(snacksNumber);\r\n    this.survivorMode = wormsNumber > 1;\r\n  }\r\n\r\n  private async initSnacks(snacksNumber: number): Promise<void> {\r\n    for (let index = 0; index < snacksNumber; index++) {\r\n      this.snacks.push(await this.setSnackPosition());\r\n    }\r\n  }\r\n\r\n  private async setSnackPosition(): Promise<Position> {\r\n    const canvasSizeInBlocks = CanvasSize.canvasSizeInBlocks(this.canvasSizeinPx, this.blockSize);\r\n    let newSnackPosition = getRandomPosition(canvasSizeInBlocks);\r\n    while (this.worms.some(x => x.body.some(y => positionsEqual(y, newSnackPosition)))) {\r\n      newSnackPosition = getRandomPosition(canvasSizeInBlocks);\r\n    }\r\n    return newSnackPosition;\r\n  }\r\n\r\n  public start(random: boolean = false): void {\r\n    this.intervalId = setInterval(() => {\r\n      this.run(random);\r\n    }, 1000 / this.fps);\r\n  }\r\n\r\n  public stop(): void {\r\n    if (this.intervalId) {\r\n      clearInterval(this.intervalId);\r\n    }\r\n  }\r\n\r\n  private run(random: boolean): void {\r\n    this.tick++;\r\n    this.worms\r\n      .filter(x => !x.dead)\r\n      .forEach(worm => {\r\n        let possibleMove = this.move(worm);\r\n        if (random) {\r\n          let tryCounter = 0;\r\n          while (!possibleMove) {\r\n            const key = Keys.LEFT + Math.floor(Math.random() * 4);\r\n            this.changeDirection(key, worm);\r\n            possibleMove = this.move(worm);\r\n            tryCounter++;\r\n            if (tryCounter >= 100) {\r\n              worm.dead = true;\r\n              possibleMove = true;\r\n            }\r\n          }\r\n          const key = Keys.LEFT + Math.floor(Math.random() * 4);\r\n          this.changeDirection(key, worm);\r\n        }\r\n      });\r\n    this.draw();\r\n    if (this.survivorMode && this.worms.filter(x => !x.dead).length <= 1) {\r\n      this.stop();\r\n    }\r\n  }\r\n\r\n  private async checkSnack(worm: Worm, index: number, headPosition: Position): Promise<void> {\r\n    const wormApproachedSnack = positionsEqual(this.snacks[index], headPosition);\r\n    if (wormApproachedSnack) {\r\n      worm.increaseSize();\r\n      this.snacks[index] = await this.setSnackPosition();\r\n    }\r\n  }\r\n\r\n  private checkAnotherWorm(worm: Worm, headPosition: Position): void {\r\n    const anotherWorm = this._anotherWormCache || this.worms.find(x => !positionsEqual(x.headPosition, worm.headPosition) && !x.dead && x.body.some(y => positionsEqual(y, headPosition)));\r\n    if (anotherWorm) {\r\n      anotherWorm.dead = true;\r\n      worm.increaseSize(anotherWorm.size);\r\n      delete this._anotherWormCache;\r\n    }\r\n  }\r\n\r\n  private move(worm: Worm): boolean {\r\n    const newPosition = this.getNewPosition(worm.direction, worm);\r\n    const possibleMove = this.checkNextMove(newPosition, worm);\r\n    if (possibleMove) {\r\n      for (let index = 0; index < this.snacks.length; index++) {\r\n        this.checkSnack(worm, index, newPosition);\r\n      }\r\n      this.checkAnotherWorm(worm, newPosition);\r\n      worm.headPosition = newPosition;\r\n      return possibleMove;\r\n    }\r\n    return possibleMove;\r\n  }\r\n\r\n  public draw(): void {\r\n    this.ctx.clearRect(0, 0, this.canvasSizeinPx.width, this.canvasSizeinPx.height);\r\n    this.worms\r\n      .filter(x => !x.dead)\r\n      .forEach(worm => {\r\n        for (let index = 0; index < worm.body.length; index++) {\r\n          const element = worm.body[index];\r\n          this.ctx.fillStyle = index === worm.body.length - 1 ? \"red\" : worm.dead ? \"burlywood\" : \"black\";\r\n          this.ctx.fillRect(\r\n            element.posX * this.blockSize,\r\n            element.posY * this.blockSize,\r\n            this.blockSize,\r\n            this.blockSize\r\n          );\r\n        }\r\n      });\r\n    for (let sI = 0; sI < this.snacks.length; sI++) {\r\n      const snack = this.snacks[sI];\r\n      this.ctx.fillStyle = \"green\";\r\n      this.ctx.fillRect(snack.posX * this.blockSize, snack.posY * this.blockSize, this.blockSize, this.blockSize);\r\n    }\r\n  }\r\n\r\n  public handleKey(key: Keys): void {\r\n    if (!Object.values(Keys).includes(key)) {\r\n      return;\r\n    }\r\n    this.changeDirection(key, this.worms[0]);\r\n  }\r\n\r\n  private changeDirection(key: Keys, worm: Worm): void {\r\n    if (\r\n      (worm.direction === Keys.DOWN && key === Keys.UP) ||\r\n      (worm.direction === Keys.UP && key === Keys.DOWN) ||\r\n      (worm.direction === Keys.LEFT && key === Keys.RIGHT) ||\r\n      (worm.direction === Keys.RIGHT && key === Keys.LEFT)\r\n    ) {\r\n      return;\r\n    }\r\n    worm.direction = key;\r\n  }\r\n\r\n  private getNewPosition(key: Keys, worm: Worm): Position {\r\n    switch (key) {\r\n      case Keys.UP:\r\n        return {\r\n          posX: worm.headPosition.posX,\r\n          posY: worm.headPosition.posY - this.step\r\n        };\r\n      case Keys.DOWN:\r\n        return {\r\n          posX: worm.headPosition.posX,\r\n          posY: worm.headPosition.posY + this.step\r\n        };\r\n      case Keys.LEFT:\r\n        return {\r\n          posX: worm.headPosition.posX - this.step,\r\n          posY: worm.headPosition.posY\r\n        };\r\n      case Keys.RIGHT:\r\n        return {\r\n          posX: worm.headPosition.posX + this.step,\r\n          posY: worm.headPosition.posY\r\n        };\r\n      default:\r\n        console.log(\"no action handler for key: \", key);\r\n        return worm.headPosition;\r\n    }\r\n  }\r\n\r\n  private checkNextMove(headPosition: Position, worm: Worm): boolean {\r\n    const outOfCanvas =\r\n      CanvasSize.canvasSizeInBlocks(this.canvasSizeinPx, this.blockSize).height < headPosition.posY + this.step ||\r\n      headPosition.posY < 0 ||\r\n      CanvasSize.canvasSizeInBlocks(this.canvasSizeinPx, this.blockSize).width < headPosition.posX + this.step ||\r\n      headPosition.posX < 0;\r\n    if (outOfCanvas) {\r\n      return false;\r\n    }\r\n    const wormApproachedHimself = worm.body.some(x => positionsEqual(x, headPosition));\r\n    if (wormApproachedHimself) {\r\n      return false;\r\n    }\r\n    this._anotherWormCache = this.worms.find(\r\n      x =>\r\n        !positionsEqual(x.headPosition, worm.headPosition) &&\r\n        !x.dead &&\r\n        x.body.some(y => positionsEqual(y, headPosition))\r\n    );\r\n    if (this._anotherWormCache) {\r\n      return this._anotherWormCache.size < worm.size;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport { Game } from \"./Game\";\r\nimport { CanvasSize } from \"./Models\";\r\n\r\ninterface GameShellProps {\r\n  canvasSize: CanvasSize;\r\n}\r\n\r\nexport default class GameShell extends React.Component<\r\n  GameShellProps,\r\n  { tick: number }\r\n> {\r\n  private canvasRef: React.RefObject<HTMLCanvasElement>;\r\n\r\n  constructor(props: GameShellProps) {\r\n    super(props);\r\n    this.canvasRef = React.createRef();\r\n\r\n    this.state = {\r\n      tick: 0\r\n    };\r\n  }\r\n\r\n  componentDidMount(): void {\r\n    const canvas = this.canvasRef.current as HTMLCanvasElement;\r\n    const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n    ctx.fillStyle = \"green\";\r\n    const game = new Game(ctx, this.props.canvasSize, 50, 3, 100, 100);\r\n    game.start(true);\r\n    window.addEventListener(\"keydown\", (event: KeyboardEvent) =>\r\n      game.handleKey(event.keyCode)\r\n    );\r\n  }\r\n\r\n  public render(): JSX.Element {\r\n    return (\r\n      <canvas\r\n        ref={this.canvasRef}\r\n        width={this.props.canvasSize.width}\r\n        height={this.props.canvasSize.height}\r\n        style={{ border: \"1px solid\" }}\r\n      />\r\n    );\r\n  }\r\n}\r\n","import React from 'react';\nimport './App.css';\nimport GameShell from './components/GameShell/GameShell';\n\nconst App: React.FC = () => {\n  const canvasWidth = window.innerWidth - 10;\n  const canvasHeight = window.innerHeight - 10;\n  return (\n    <div className=\"App\">\n        <GameShell canvasSize={{ width: canvasWidth, height: canvasHeight }}></GameShell>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}