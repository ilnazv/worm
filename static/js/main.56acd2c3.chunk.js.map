{"version":3,"sources":["components/GameShell/Models.ts","components/GameShell/Worm.ts","components/GameShell/Snack.ts","components/GameShell/Canvas.ts","components/GameShell/Game.tsx","components/GameShell/GameShell.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Keys","Position","posX","posY","positionsEqual","right","ColoredDot","color","Worm","_headPosition","_size","_direction","DOWN","_step","body","dead","this","push","headPosition","value","size","direction","UP","LEFT","RIGHT","console","log","worms","anotherWorm","approachedAnotherWorm","increaseSize","find","x","some","y","canvasSize","pointIsInPoly","isInside","polygon","minX","Math","min","map","minY","maxX","max","maxY","index","width","height","i","j","length","shift","key","Snack","occupiedPosition","canvas","newSnackPosition","getRandomPosition","Canvas","_blockSize","ctx","floor","random","canvasSizeInBlocks","position","dots","clearRect","dot","fillStyle","fillRect","Game","canvasSizeinPx","fps","blockSize","wormsNumber","snacksNumber","intervalId","tick","snacks","survivorMode","extraDots","initSnacks","newRandomly","flatMap","setInterval","run","clearInterval","filter","forEach","worm","possibleDirections","window","possibleMove","move","splice","draw","stop","element","sI","snack","newPosition","nextPosition","checkNextMove","checkSnack","checkAnotherWorm","Object","values","includes","outOfCanvas","checkHimself","GameShell","props","canvasRef","React","createRef","state","current","getContext","game","start","addEventListener","event","handleKey","keyCode","ref","style","border","Component","App","canvasWidth","innerWidth","canvasHeight","innerHeight","className","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.56acd2c3.chunk.js","sourcesContent":["export class Position {\r\n  constructor(public posX: number, public posY: number) {}\r\n\r\n  public positionsEqual = (right: Position): boolean => {\r\n    return this.posX === right.posX && this.posY === right.posY;\r\n  };\r\n}\r\n\r\nexport enum Keys {\r\n  LEFT = 37,\r\n  UP = 38,\r\n  RIGHT = 39,\r\n  DOWN = 40\r\n}\r\n\r\nexport interface ISize {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport class ColoredDot extends Position {\r\n  constructor(posX: number, posY: number, public color: string) {\r\n    super(posX, posY);\r\n  }\r\n}\r\n","import { Position, Keys, ISize } from \"./Models\";\r\n\r\nexport class Worm {\r\n  public get headPosition(): Position {\r\n    return this._headPosition;\r\n  }\r\n\r\n  public set headPosition(value: Position) {\r\n    if (this.body.length >= this.size) {\r\n      this.body.shift();\r\n    }\r\n    this.body.push(value);\r\n    this._headPosition = value;\r\n  }\r\n\r\n  public body: Position[] = [];\r\n\r\n  public increaseSize(value: number = 1): void {\r\n    this._size = this.size + value;\r\n  }\r\n\r\n  public dead = false;\r\n\r\n  public get size(): number {\r\n    return this._size;\r\n  }\r\n\r\n  public get direction(): Keys {\r\n    return this._direction;\r\n  }\r\n\r\n  public set direction(key: Keys) {\r\n    const wrongDirection =\r\n      (this._direction === Keys.DOWN && key === Keys.UP) ||\r\n      (this._direction === Keys.UP && key === Keys.DOWN) ||\r\n      (this._direction === Keys.LEFT && key === Keys.RIGHT) ||\r\n      (this._direction === Keys.RIGHT && key === Keys.LEFT);\r\n\r\n    if (!wrongDirection) {\r\n      this._direction = key;\r\n    }\r\n  }\r\n\r\n  public nextPosition(direction: Keys): Position {\r\n    switch (direction) {\r\n      case Keys.UP:\r\n        return new Position(this.headPosition.posX, this.headPosition.posY - this._step);\r\n      case Keys.DOWN:\r\n        return new Position(this.headPosition.posX, this.headPosition.posY + this._step);\r\n      case Keys.LEFT:\r\n        return new Position(this.headPosition.posX - this._step, this.headPosition.posY);\r\n      case Keys.RIGHT:\r\n        return new Position(this.headPosition.posX + this._step, this.headPosition.posY);\r\n      default:\r\n        console.log(\"no action handler for key: \", direction);\r\n        return this.headPosition;\r\n    }\r\n  }\r\n\r\n  public checkAnotherWorm(headPosition: Position, worms: Worm[]): void {\r\n    const anotherWorm = this.approachedAnotherWorm(worms, headPosition);\r\n    if (anotherWorm) {\r\n      anotherWorm.dead = true;\r\n      this.increaseSize(anotherWorm.size);\r\n    }\r\n  }\r\n\r\n  public approachedAnotherWorm(worms: Worm[], headPosition: Position): Worm | undefined {\r\n    return worms.find(\r\n      x => !x.headPosition.positionsEqual(headPosition) && !x.dead && x.body.some(y => y.positionsEqual(headPosition))\r\n    );\r\n  }\r\n\r\n  public checkHimself(headPosition: Position, canvasSize: ISize): boolean {\r\n    return this.body.some(x => x.positionsEqual(headPosition)) || this.pointIsInPoly(headPosition, canvasSize);\r\n  }\r\n\r\n  public pointIsInPoly(headPosition: Position, canvasSize: ISize): boolean {\r\n    let isInside = false;\r\n\r\n    const polygon: Position[] = [...this.body];\r\n\r\n    const minX = Math.min(...polygon.map(x => x.posX));\r\n    const minY = Math.min(...polygon.map(x => x.posY));\r\n    const maxX = Math.max(...polygon.map(x => x.posX));\r\n    const maxY = Math.max(...polygon.map(x => x.posY));\r\n\r\n    if (minX === 0) {\r\n      for (let index = minY; index < maxY; index++) {\r\n        polygon.push(new Position(-1, index));\r\n      }\r\n    }\r\n\r\n    if (minY === 0) {\r\n      for (let index = minX; index < maxX; index++) {\r\n        polygon.push(new Position(index, -1));\r\n      }\r\n    }\r\n\r\n    if (maxX === canvasSize.width) {\r\n      for (let index = minY; index < maxY; index++) {\r\n        polygon.push(new Position(canvasSize.width + 1, index));\r\n      }\r\n    }\r\n\r\n    if (maxY === canvasSize.height) {\r\n      for (let index = minX; index < maxX; index++) {\r\n        polygon.push(new Position(index, canvasSize.height + 1));\r\n      }\r\n    }\r\n\r\n    if (headPosition.posX < minX || headPosition.posX > maxX || headPosition.posY < minY || headPosition.posY > maxY) {\r\n      return false;\r\n    }\r\n\r\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\r\n      if (\r\n        polygon[i].posY > headPosition.posY !== polygon[j].posY > headPosition.posY &&\r\n        headPosition.posX <\r\n          ((polygon[j].posX - polygon[i].posX) * (headPosition.posY - polygon[i].posY)) /\r\n            (polygon[j].posY - polygon[i].posY) +\r\n            polygon[i].posX\r\n      ) {\r\n        isInside = !isInside;\r\n      }\r\n    }\r\n\r\n    return isInside;\r\n  }\r\n\r\n  constructor(\r\n    private _headPosition: Position = new Position(0, 0),\r\n    private _size: number = 3,\r\n    private _direction: Keys = Keys.DOWN,\r\n    private _step: number = 1\r\n  ) {\r\n    this.body.push(this.headPosition);\r\n  }\r\n}\r\n","import { Position } from './Models';\r\nimport { Canvas } from './Canvas';\r\n\r\nexport class Snack extends Position {\r\n  public static newRandomly(occupiedPosition: Position[], canvas: Canvas): Snack {\r\n    let newSnackPosition = canvas.getRandomPosition();\r\n    while (occupiedPosition.some(y => y.positionsEqual(newSnackPosition))) {\r\n      newSnackPosition = canvas.getRandomPosition();\r\n    }\r\n    const { posX, posY } = newSnackPosition;\r\n    return new this(posX, posY);\r\n  }\r\n}\r\n","import { ISize, Position, ColoredDot } from \"./Models\";\r\n\r\nexport class Canvas {\r\n  private size: ISize = { width: 0, height: 0 };\r\n\r\n  constructor(width: number, height: number, private _blockSize: number = 1, private ctx: CanvasRenderingContext2D) {\r\n    this.size = { width, height };\r\n  }\r\n\r\n  public getRandomPosition(): Position {\r\n    return new Position(\r\n      Math.floor(Math.random() * this.canvasSizeInBlocks.width),\r\n      Math.floor(Math.random() * this.canvasSizeInBlocks.height)\r\n    );\r\n  }\r\n\r\n  public get canvasSizeInBlocks(): ISize {\r\n    return { width: Math.floor(this.size.width / this._blockSize), height: Math.floor(this.size.height / this._blockSize) };\r\n  }\r\n\r\n  public outOfCanvas(position: Position): boolean {\r\n    return (\r\n      this.canvasSizeInBlocks.height < position.posY ||\r\n      position.posY < 0 ||\r\n      this.canvasSizeInBlocks.width < position.posX ||\r\n      position.posX < 0\r\n    );\r\n  }\r\n\r\n  public draw(dots: ColoredDot[]): void {\r\n    this.ctx.clearRect(0, 0, this.size.width, this.size.height);\r\n    for (let index = 0; index < dots.length; index++) {\r\n      const dot = dots[index];\r\n      this.ctx.fillStyle = dot.color;\r\n      this.ctx.fillRect(dot.posX * this._blockSize, dot.posY * this._blockSize, this._blockSize, this._blockSize);\r\n    }\r\n  }\r\n}\r\n","import { Keys, Position, ISize, ColoredDot } from \"./Models\";\r\nimport { Worm } from \"./Worm\";\r\nimport { Snack } from \"./Snack\";\r\nimport { Canvas } from \"./Canvas\";\r\n\r\nexport class Game {\r\n  private intervalId?: NodeJS.Timeout;\r\n  private tick = 0;\r\n  private snacks: Snack[] = [];\r\n  private worms: Worm[] = [];\r\n  private survivorMode = false;\r\n  private canvas: Canvas;\r\n\r\n  private extraDots: Position[] = [];\r\n\r\n  constructor(\r\n    ctx: CanvasRenderingContext2D,\r\n    canvasSizeinPx: ISize,\r\n    private fps = 50,\r\n    private blockSize = 100,\r\n    wormsNumber = 1,\r\n    snacksNumber = 1\r\n  ) {\r\n    this.canvas = new Canvas(canvasSizeinPx.width, canvasSizeinPx.height, this.blockSize, ctx);\r\n    for (let index = 0; index < wormsNumber; index++) {\r\n      this.worms.push(new Worm(this.canvas.getRandomPosition()));\r\n    }\r\n    this.initSnacks(snacksNumber);\r\n    this.survivorMode = wormsNumber > 1;\r\n  }\r\n\r\n  private initSnacks(snacksNumber: number): void {\r\n    for (let index = 0; index < snacksNumber; index++) {\r\n      this.snacks.push(Snack.newRandomly(this.worms.flatMap(x => x.body), this.canvas));\r\n    }\r\n  }\r\n\r\n  public start(random: boolean = false): void {\r\n    this.intervalId = setInterval(() => {\r\n      this.run(random);\r\n    }, 1000 / this.fps);\r\n  }\r\n\r\n  public stop(): void {\r\n    if (this.intervalId) {\r\n      clearInterval(this.intervalId);\r\n    }\r\n  }\r\n\r\n  private run(random: boolean): void {\r\n    this.tick++;\r\n    this.worms\r\n      .filter(x => !x.dead)\r\n      .forEach(worm => {\r\n        if (random) {\r\n          const possibleDirections: number[] = [Keys.DOWN, Keys.LEFT, Keys.RIGHT, Keys.UP];\r\n          (window as any).worm = worm;\r\n          let possibleMove = false;\r\n          let key: Keys = Keys.DOWN;\r\n          do {\r\n            if (possibleDirections.length === 0) {\r\n              worm.dead = true;\r\n              possibleMove = true;\r\n            } else {\r\n              const index = Math.floor(Math.random() * possibleDirections.length);\r\n              key = possibleDirections[index];\r\n              possibleMove = this.move(worm, key);\r\n              possibleDirections.splice(index, 1);\r\n            }\r\n          } while (!possibleMove); \r\n          worm.direction = key;\r\n        }\r\n      });\r\n    this.draw();\r\n    if (this.survivorMode && this.worms.filter(x => !x.dead).length <= 1) {\r\n      this.stop();\r\n    }\r\n  }\r\n\r\n  private draw(): void {\r\n    const dots: ColoredDot[] = [];\r\n    this.worms\r\n      .filter(x => !x.dead)\r\n      .forEach(worm => {\r\n        for (let index = 0; index < worm.body.length; index++) {\r\n          const element = worm.body[index];\r\n          const color = worm.dead ? \"burlywood\" : \"black\";\r\n          dots.push(new ColoredDot(element.posX, element.posY, color));\r\n        }\r\n        dots.push(new ColoredDot(worm.headPosition.posX, worm.headPosition.posY, \"red\"));\r\n      });\r\n    for (let sI = 0; sI < this.snacks.length; sI++) {\r\n      const snack = this.snacks[sI];\r\n      const color = \"green\";\r\n      dots.push(new ColoredDot(snack.posX, snack.posY, color));\r\n    }\r\n    dots.push(...(this.extraDots.map(x => new ColoredDot(\r\n      x.posX,\r\n      x.posY,\r\n      \"blue\"\r\n    ))));\r\n    this.canvas.draw(dots);\r\n  }\r\n\r\n  private checkSnack(worm: Worm, index: number, headPosition: Position): void {\r\n    const wormApproachedSnack = this.snacks[index].positionsEqual(headPosition);\r\n    if (wormApproachedSnack) {\r\n      worm.increaseSize();\r\n      this.snacks[index] = Snack.newRandomly(this.worms.flatMap(x => x.body), this.canvas);\r\n    }\r\n  }\r\n\r\n  private move(worm: Worm, direction: Keys): boolean {\r\n    const newPosition = worm.nextPosition(direction);\r\n    const possibleMove = this.checkNextMove(newPosition, worm);\r\n    if (possibleMove) {\r\n      for (let index = 0; index < this.snacks.length; index++) {\r\n        this.checkSnack(worm, index, newPosition);\r\n      }\r\n      worm.checkAnotherWorm(newPosition, this.worms);\r\n      worm.headPosition = newPosition;\r\n      return possibleMove;\r\n    }\r\n    return possibleMove;\r\n  }\r\n\r\n  public handleKey(key: Keys): void {\r\n    if (!Object.values(Keys).includes(key)) {\r\n      return;\r\n    }\r\n    this.worms[0].direction = key;\r\n  }\r\n\r\n  private checkNextMove(headPosition: Position, worm: Worm): boolean {\r\n    if (this.canvas.outOfCanvas(headPosition)) {\r\n      return false;\r\n    }\r\n    const wormApproachedHimself = worm.checkHimself(headPosition, this.canvas.canvasSizeInBlocks);\r\n    if (wormApproachedHimself) {\r\n      return false;\r\n    }\r\n    const anotherWorm = worm.approachedAnotherWorm(this.worms, headPosition);\r\n    if (anotherWorm) {\r\n      return anotherWorm.size <= worm.size;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport { Game } from \"./Game\";\r\nimport { ISize } from \"./Models\";\r\n\r\ninterface GameShellProps {\r\n  canvasSize: ISize;\r\n}\r\n\r\nexport default class GameShell extends React.Component<\r\n  GameShellProps,\r\n  { tick: number }\r\n> {\r\n  private canvasRef: React.RefObject<HTMLCanvasElement>;\r\n\r\n  constructor(props: GameShellProps) {\r\n    super(props);\r\n    this.canvasRef = React.createRef();\r\n\r\n    this.state = {\r\n      tick: 0\r\n    };\r\n  }\r\n\r\n  componentDidMount(): void {\r\n    const canvas = this.canvasRef.current as HTMLCanvasElement;\r\n    const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n    ctx.fillStyle = \"green\";\r\n    const game = new Game(ctx, this.props.canvasSize, 50, 3, 100, 100);\r\n    game.start(true);\r\n    window.addEventListener(\"keydown\", (event: KeyboardEvent) =>\r\n      game.handleKey(event.keyCode)\r\n    );\r\n  }\r\n\r\n  public render(): JSX.Element {\r\n    return (\r\n      <canvas\r\n        ref={this.canvasRef}\r\n        width={this.props.canvasSize.width}\r\n        height={this.props.canvasSize.height}\r\n        style={{ border: \"1px solid\" }}\r\n      />\r\n    );\r\n  }\r\n}\r\n","import React from 'react';\nimport './App.css';\nimport GameShell from './components/GameShell/GameShell';\n\nconst App: React.FC = () => {\n  const canvasWidth = window.innerWidth - 10;\n  const canvasHeight = window.innerHeight - 10;\n  return (\n    <div className=\"App\">\n        <GameShell canvasSize={{ width: canvasWidth, height: canvasHeight }}></GameShell>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}